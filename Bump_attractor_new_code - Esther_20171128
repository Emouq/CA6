import matplotlib.pyplot as plt
import numpy as np
import scipy as sp
import networkx as nx
import scipy.linalg

# Parameters

## time
total_Time = 5000 # total time of the simulation in ms (cf. Fig 1.a)
dt = 2 # integration step in ms
nsteps = int(np.floor(total_Time/dt))
t = [x*dt for x in range(nsteps)]

## cue
npop = 8 # number of cues presented
cue = [x*2*np.pi/npop for x in range(npop)] # list of cues
cue_number = 3 # to be changed

# Firing rate
N = 512 # number of neurons in the rate model (512 excitatory neurons and 512 inhibitory neurons)
thetas_preferred = [x*2*np.pi/N for x in range(N)] # list of prefered angles for the N neurons
rE = np.zeros(N)
rI = np.zeros(N)

# Connectivity matrices

## Connectivity matrix among excitatory neurons
GEE=6
GEI=4
GIE=3.4
GII=0.85

sigma = 0.08 # parameter defining concentration of e-to-e connectivity
WEE = np.ones((N,N),float)
WEE_line1 = [1/(sigma*np.sqrt(2*np.pi))*np.exp(-x**2/(2*sigma**2)) for x in range(N)]
for i in range(N):
    for j in range(i):
        WEE[i][j] = WEE_line1[N-i+j]
    for j in range(i,N):
        WEE[i][j] = WEE_line1[j-i]

WEI = np.ones((N,N),float)*GEI
WIE = np.ones((N,N),float)*GIE
WII = np.ones((N,N),float)*GII

# Connectivity equations

Im = 0
I0I=0.5
I0E=0.2
sigmae=1
sigmai=3
tauE = 20
tauI = 10

## Input-output function
def transfer(x):
    if x>0 and x<1:
        x=x*x
    if x>=1:
        x=np.sqrt(4*x-3)
    return x

# Simultaion

## Parameters

stimon = 1000	# time when external stimulus is applied in ms
stimoff = 1500	# time when external stimulus ceases in ms
stim = 200  	# strength of external stimulus
delayend=4500	# time when delay ends in ms, and external input is applied to erase memory

x_cue = N/npop*cue_number
stimulus = [stim*1/(sigma*np.sqrt(2*np.pi))*np.exp(-(x-x_cue)**2/(2*sigma**2)) for x in range(N)] # distribution gaussienne centrÃ©e sur le cue


## Simulation loop

mean_rE = np.zeros(nsteps)

for k in range(nsteps):

    # additive noise for each population
    white_Gaussian_noise = np.random.normal(0,1,N)
    noiseE = sigmae * white_Gaussian_noise
    noiseI = sigmai * white_Gaussian_noise

    # current input to each population
    IE = GEE*np.dot(WEE,rE) + (I0E - np.dot(WIE,rI))  # np.dot est le fonction du produit matriciel
    II = np.dot(WEI,rE) + I0I - np.dot(WII,rI)

    # external task-dependent inputs
    if k > stimon and k < stimoff:
        IE = IE + stimulus # "incresased current input to subset of neurons theta_i near stimulus location theta_s"

    if k > delayend:
        IE = IE - stimulus

    # integration with time-step: Newton method
    for i in range(N):
        rE[i] = rE[i] + (transfer(IE[i]) - rE[i] + noiseE[i]) * dt/tauE
        rI[i] = rI[i] + (transfer(II[i]) - rI[i] + noiseI[i]) * dt/tauI

    mean_rE[k] = np.mean(rE[0:3*64])
    # graphic

plt.plot(t,mean_rE,'r')
plt.show()
